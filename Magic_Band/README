TEMA1 - SDA
	Pentru implementarea temei am ales sa am 3 fisiere de tip header unde sa am functiile pentru banda, stiva si respectiv coada si un fisier main numit tema1.c.
	In fisierul banda.h am declarat structurile pentru un element din banda si pentru santinela(ce pointeaza catre inceputul benzii) si pentru pozitia curenta a degetului. Am creat lista ( createList() ) si apoi am initializat o, alocand memorie pentru santinela( initList() ). Am facut o functie pentru a creea un nou element ce urmeaza sa fie adaugat la banda. Mai departe avem functia "insertFirst" care ne va ajuta sa aduagam la inceputul listei dupa, santinela, un element. Apoi este functia "freeList" cu ajutorul careia vom dealoca memoria alocata benzii. Functia "insertLeft" adauga un element la stanga folosita pentru comanda "INSERT_LEFT". Urmeaza functiile "searchRight" si "searchLeft" pe care le vom folosi pentru comenzile "MOVE_RIGHT_CHAR", respectiv "MOVE_LEFT_CHAR". Acestea cauta in banda incepand de la elementul curent in functie de directia ceruta si returneaza 1 daca a fost gasit elementul cautat si actualizeaza elementul curent si 0 in caz contrar.
	In fisierul coada.h am declarat structurile penrtu o comanda din coada si cea pentru coada ce contine capul si coada (head, tail). Functia "createCommand" aloca memorie pentru o comanda ce urmeaza sa fie adaugata la coada, alocand memorie si pentru elementul de tip "data" care va retine cuvantul. Functia "allocQueue" initializeaza coada. Functia "enqueue" adauga la coada comanda data ca parametru, creand mai intai nodul aferent. Urmeaza functia "queueEmpty" ce returneaza 1 daca coada e goala si 0 in caz contrar. Urmeaza comanda "dequeue" ce sterge din coada comanda ce s a executat, ce reprezinta head ul, iar apoi functia "freeQueue" elibereaza memoria alocata cozii.
	In fisierul stive.h avem functiile si structurile pentru stivele de UNDO si REDO. Prima structura este pentru un element din stiva UNDO ce contine pointer la un element din banda fiind de tip "Banda". A doua este cea care retine pozitia din varful stivei. In acelasi mod sunt reprezentate si urmatoarele 2, doar ca pentru stiva REDO. Urmeaza 2 functii pentru a initializeaza stivele( UNDO, apoi REDO) ce sunt facute in acelasi fel. Apoi cele 2 functii ce verifica daca stivele sunt goale verificand doar daca exista un element in varf. Functiile "Upush" si "Rpush" adauga un element nou in stiva de UNDO, respectiv REDO, alocand memorie pentru el si apoi facand linkarea cu urmatorul element, cel nou devenind top. Functiile "popU" si "popR" sterg elementul din varf, eliberand memoria alocata, daca stiva nu este goala. Functiile "freeU" si "freeR" elibereaza memoria alocata pentru stive si stergand elemente din stiva daca mai exista. Ultimele 2 functii "deleteElemU" si deleteElemR" sterg toate elementele din stiva atunci cand intalnesc comanda WRITE, fara a sterge si stiva de UNDO sau REDO.
	In main (tema1.c) vom realiza linkarea cu fisierele header si declaram bibliotecile necesare. In functia main vom incepe dezchizand fisierul de unde se va face citirea(tema1.in), iar apoi cel in care se va scrie(tema1.out). Declaram si nr_cmd ce va retine numarul comenzilor, iar apoi un vector char pentru comenzi. Facem initializarea benzii, a cozii si a stivelor UNDO/REDO si adaugam primul element din banda "#", iar apoi citim nr de comenzi. Cu ajutorul functiei fgets() citim linie cu linie comenzile. Daca intalnim comanda EXECUTE vom efectua comenzile aflate in coada, iar in sens contrar, daca intalnim operatii de tip QUERRY sau UNDO/REDO le vom executa direct. Pentru comanda "SHOW" incepem de la elementul de dupa santinela si le afisam pe toate punand elem curent intre bari | |. Comanda SHOW_CURRENT afiseaza doar elem curent. Daca intalnim operatii UNDO/REDO mutam degetul pe pozitia din varful stivei de UNDO/REDO (depinde de comanda) si adaugam in stiva opusa pozitia trecuta a degetului cu ajutorul lui Upush sau Rpush si eliminam elementul din varf unde am mutat degetul. Daca intalnim comenzi de tip UPDATE le adaugam in coada cu functia "enqueue" si asteptam comanda EXECUTE. Cand este primita, in functie de primul element din coada, este executata comanda. Daca este MOVE_RIGHT, se verifica daca mai exista element la dreapta, daca nu il adauga cu "inser" si adauga in stiva UNDO pozitia de pe care s a mutat degetul. La MOVE_LEFT, daca suntem pe prima poz nu se intampla nimic, iar daca nu mutam degetul la stanga si adaugam fosta pozitie in UNDO. La MOVE_RIGHT_CHAR vom cauta daca exista elementul dat cu "searchRight", daca nu il inseram. Pt MOVE_LEFT_CHAR cautam cu "searchLeft", iar daca nu gasim se afiseaza mesajul ERROR. La comanda WRITE se scrie la pozitia curenta elem indicat si se sterg pozitiile retinute in stivele UNDO/REDO. Pentru INSERT_RIGHT, folosim functia insert sa adaugam la dreapta caracterul si mutam degetul, iar la INSERT_lEFT, daca suntem pe prima poz dupa santinela se afiseaza ERROR, iar altfel cu ajutorul lui insertLeft adaugam caracterul la stanga. Dupa fiecare operatie efectuata eliminam comanda din coada cu dequeue. La sfarsit inchidem fisierele in si out si dam free la memoria utilizata.
	
	Puncte la teste:
	Total: 100/100
	Valgrind: 20/20
